/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <arpa/inet.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include "idManager.h"
#include "../includes.h"
#define FILENAME "ids.dat"
#define HOST_KIND_AMOUNT (CONSUMMER_KIND_AMOUNT + 1)

struct hostInfo {
    char address[MAX_ADDRESS_LENGTH];
    long mtype;
};

struct hostArray {
    unsigned amount;
    unsigned lastUsed;
    struct hostInfo * hosts;
};

struct fileData {
    long nextMtype;
    struct hostArray producers, disks, processors, motherboards;
};

void data2array(struct fileData * data, struct hostArray arr[4]) {
    arr[0] = data->producers;
    arr[1] = data->disks;
    arr[2] = data->processors;
    arr[3] = data->motherboards;
}

void array2data(struct fileData * data, struct hostArray arr[4]) {
    data->producers = arr[0];
    data->disks = arr[1];
    data->processors = arr[2];
    data->motherboards = arr[3];
}

void addHost(struct hostArray *array, struct hostInfo host) {
    if (array->hosts) {
        array->hosts = realloc(array->hosts, (array->amount + 1) * sizeof (struct hostInfo));
    } else {
        array->hosts = malloc(sizeof (struct hostInfo));
    }
    array->hosts[array->amount++] = host;
}

struct fileData readFile(const char * filename) {
    struct fileData data;
    unsigned i;
    struct hostArray temp[HOST_KIND_AMOUNT];
    FILE * file = fopen(filename, "rb");
    if (file) {
        if (fread(&(data.nextMtype), sizeof (data.nextMtype), 1, file)) {
            for (i = 0; i < HOST_KIND_AMOUNT; i++) {
                fread(&(temp[i].amount), sizeof (temp[i].amount), 1, file);
                fread(&(temp[i].lastUsed), sizeof (temp[i].lastUsed), 1, file);
            }
            for (i = 0; i < HOST_KIND_AMOUNT; i++) {
                if (temp[i].amount) {
                    temp[i].hosts = malloc(sizeof (struct hostInfo) * temp[i].amount);
                    fread(temp[i].hosts, sizeof (struct hostInfo), temp[i].amount, file);
                } else {
                    temp[i].hosts = NULL;
                }
            }
            array2data(&data, temp);
        } else {
            bzero(&data, sizeof (data));
            data.nextMtype = M_PROD + 1;
        }
        fclose(file);
    } else {
        bzero(&data, sizeof (data));
        data.nextMtype = M_PROD + 1;
    }
    return data;
}

bool_t writeFile(const char * filename, struct fileData data) {
    FILE * file = fopen(filename, "wb");
    struct hostArray temp[HOST_KIND_AMOUNT];
    unsigned i;
    data2array(&data, temp);
    if (file) {
        fwrite(&(data.nextMtype), sizeof (data.nextMtype), 1, file);
        for (i = 0; i < HOST_KIND_AMOUNT; i++) {
            fwrite(&(temp[i].amount), sizeof (temp[i].amount), 1, file);
            fwrite(&(temp[i].lastUsed), sizeof (temp[i].lastUsed), 1, file);
        }
        for (i = 0; i < HOST_KIND_AMOUNT; i++) {
            if (temp[i].amount) {

                fwrite(temp[i].hosts, sizeof (struct hostInfo), temp[i].amount, file);
            }
        }
        fclose(file);
    } else {
        return FALSE;
    }
    return TRUE;
}

void clearData(struct fileData* dataPtr) {
    struct hostArray temp[HOST_KIND_AMOUNT];
    unsigned i;
    data2array(dataPtr, temp);

    dataPtr->nextMtype = M_CONS + 1;
    for (i = 0; i < HOST_KIND_AMOUNT; i++) {
        if (temp[i].hosts) {
            free(temp[i].hosts);
        }
        temp[i].hosts = (struct hostInfo*) NULL;
        temp[i].amount = 0;
        temp[i].lastUsed = 0;
    }
    array2data(dataPtr, temp);
}

registerResult *
register_consummer_1_svc(consummerType *type, struct svc_req *rqstp) {
    static registerResult result;
    char * ctype;
    struct fileData data;
    struct hostInfo host;

    data = readFile(FILENAME);

    host.mtype = data.nextMtype;
    strncpy(host.address, inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr), sizeof (host.address));
    switch (*type) {
        case DISKS:
            addHost(&(data.disks), host);
            ctype = "DISKS";
            break;
        case PROCCESSORS:
            addHost(&(data.processors), host);
            ctype = "PROCESSORS";
            break;
        case MOTHERBOARDS:
            addHost(&(data.motherboards), host);
            ctype = "MOTHERBOARDS";
            break;
        default:
            result.cod_ret = -1;
            result.registerResult_u.error = UNKNOWN_CONSUMMER_TYPE;
            return &result;
    }
    result.registerResult_u.mtype = host.mtype;
    data.nextMtype++;
    if (!writeFile(FILENAME, data)) {
        result.cod_ret = -1;
        result.registerResult_u.error = FILE_ACCESS_FAILURE;
        clearData(&data);
        return &result;
    }
    result.cod_ret = 0;
    clearData(&data);

    printf("REGISTER CONSUMMER %s as id %3ld from %s\n", ctype, host.mtype, host.address);
    return &result;
}

queryResult *
query_consummers_1_svc(void *nothing, struct svc_req *rqstp) {
    static queryResult result;
    struct fileData data = readFile(FILENAME);
    if (data.disks.amount) {
        result.queryResult_u.mtypes.disks = data.disks.hosts[data.disks.lastUsed].mtype;
        data.disks.lastUsed = (data.disks.lastUsed + 1) % data.disks.amount;
    }
    if (data.processors.amount) {
        result.queryResult_u.mtypes.processors = data.processors.hosts[data.processors.lastUsed].mtype;
        data.processors.lastUsed = (data.processors.lastUsed + 1) % data.processors.amount;
    }
    if (data.motherboards.amount) {
        result.queryResult_u.mtypes.motherboards = data.motherboards.hosts[data.motherboards.lastUsed].mtype;
        data.motherboards.lastUsed = (data.motherboards.lastUsed + 1) % data.motherboards.amount;
    }
    if (!writeFile(FILENAME, data)) {
        result.cod_ret = -1;
        result.queryResult_u.error = FILE_ACCESS_FAILURE;
        clearData(&data);
        return &result;
    }
    clearData(&data);
    result.cod_ret = 0;
    printf("QUERY: %ld %ld %ld\n", result.queryResult_u.mtypes.disks, result.queryResult_u.mtypes.processors, result.queryResult_u.mtypes.motherboards);

    return &result;
}

getResult *
get_1_svc(long *mtype, struct svc_req *rqstp) {
    static getResult result;
    static struct hostInfo host;
    unsigned i, j;
    struct fileData data = readFile(FILENAME);
    struct hostArray temp[HOST_KIND_AMOUNT];
    data2array(&data, temp);
    host.mtype = 0;
    for (i = 0; i < HOST_KIND_AMOUNT && host.mtype == 0; i++) {
        for (j = 0; j < temp[i].amount && host.mtype == 0; j++) {
            if (temp[i].hosts[j].mtype == *mtype) {
                host = temp[i].hosts[j];
            }
        }
    }
    clearData(&data);
    if (host.mtype) {
        result.cod_ret = 0;
        strncpy(result.getResult_u.address, host.address, MAX_ADDRESS_LENGTH);
        printf("GET %3ld is %s\n", host.mtype, host.address);
    } else {

        result.cod_ret = -1;
        result.getResult_u.error = INVIALID_ID;
    }
    return &result;
}

registerResult *
register_producer_1_svc(void *nothing, struct svc_req *rqstp) {
    static registerResult result;
    struct fileData data;
    struct hostInfo host;
    data = readFile(FILENAME);
    host.mtype = data.nextMtype;
    strncpy(host.address, inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr), sizeof (host.address));
    addHost(&(data.producers), host);

    result.registerResult_u.mtype = host.mtype;
    data.nextMtype++;
    if (!writeFile(FILENAME, data)) {
        result.cod_ret = -1;
        result.registerResult_u.error = FILE_ACCESS_FAILURE;
        clearData(&data);
        return &result;
    }
    result.cod_ret = 0;
    clearData(&data);

    printf("REGISTER PRODUCER as id %3ld from %s\n", host.mtype, host.address);

    result.registerResult_u.mtype = host.mtype;

    return &result;
}
